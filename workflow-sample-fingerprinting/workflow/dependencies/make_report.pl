#!/usr/bin/perl -w

=head2 SUMMARY
 
 Script for filtering and clustering genotypes, splitting matrix into a set of smaller chunks and producing html report with images

=head2 USAGE

 make_report.pl --datadir=[required] --studyname=[required] --matrix=[required] --refsnps=[required] --tempdir=[optional]

 Script requires similarity matrix (tab-delimited), directory with data (vcf files) studyname and number of control points (SNPs)
 Optionally it uses tempdir parameter which may point to a directory with coverage depth data if that is different than datadir

=head2 EXAMPLES

 ./make_report.pl --matrix=PCSI_WG.matrix.all.txt --datadir=. --tempdir=./GATK.out/PCSI_EX.depth/ --studyname=PCSI --refsnps=400 > index.html

 ./make_report.pl --matrix=PCSI_EX.matrix.all.txt --datadir=blah/ --studyname=PCSI --refsnps=400 > PCSI_test.html 

=cut

# =================================================================================================================
# Script for filtering and clustering genotypes, splitting matrix into a set of smaller chunks and producing images 
# + html wrapper
# =================================================================================================================

use strict;
use Getopt::Long;
use CGI qw/:standard/;
use IO::File;
use FindBin qw($Bin);
use Data::Dumper;

use constant THRESHOLD=>30; # That many SNPs every genotype should have
use constant DEBUG=>0;
use constant NOGARBAGE=>1; # Filter (or not) entries that have only 1 or/and 0
use constant SAMPLESPERSLICE=>8;
use constant JACCARDOFFSET=>0.1; # Allow lanes to be reassigned to their parent cluster if they similarity to the lanes from other donors is not that great

my($datadir,$tempdir,$matrix,$studyname,$refsnps); # external parameters
my($snp_index,%samples,%sample_counter,%ids,%filtered,@lines,%reports,%flagged); # internal variables

# %flagged structure: %flagged = (samples=>{} files=>{}) multiple levels of flagging
%flagged = (samples=>{}, files=>{});

my $pngsize = 750;

=head2 reports hash structure

 reports (for each slice) should contain these data:

 img      => image of the heatmap
 fp       => image of the fingerprints
 title    => title that should list all samples in the cluster
 matrix   => path to file with similarity matrix (jaccard indexes) for a heatmap
 genotype => path to file with genotype info for a heatmap

=cut

my @colors = qw/red orange yellow green lightblue blue purple darkgreen black pink/; 
my $USAGE  = "make_report.pl --datadir=[req] --studyname=[req] --matrix=[req] --refsnps=[req] --tempdir=[opt]";
my $result = GetOptions ('datadir=s'    => \$datadir, # working (output) directory
                         'tempdir=s'    => \$tempdir,  # directory with temporary GATK files
                         'matrix=s'     => \$matrix,  # file with calculated indexes
                         'refsnps=i'    => \$refsnps, # number of SNPs in reference checkpoint list
                         'studyname=s'  => \$studyname);
if (!$matrix || !$refsnps || !$studyname ) { die $USAGE; }
# First step -load the data, filter files with not enogh SNPs 
$datadir.="/" if $datadir !~m!/$!;
$tempdir ||=$datadir;
$tempdir.="/" if $tempdir !~m!/$!;

# =====================================================================================
# Reading from the matrix generated by the workflow (csv format, provisioned)
# =====================================================================================
if ($matrix && -e $matrix) {
 my $fh = new IO::File("<$matrix") or die "There was an error reading file [$matrix]";
 my $firstline = <$fh>;
 chomp($firstline);
 my @heads = split("\t",$firstline);
 map {if ($heads[$_]=~/^SNP/){$snp_index = $_}} (0..$#heads);

 $snp_index or die "The matrix file [$matrix] is missing the column with number of SNPs called per genotype";
 @lines = ($firstline);

 # Find what is the index of 'SNPs' column and use it later to remove those entries with fewer than THRESHOLD SNPs
 while (<$fh>) {
  chomp;
  my @temp = split("\t");
  my $trimmed_name = $temp[0];
  if ($trimmed_name =~/^SWID/) {
     $trimmed_name=~s/(SWID_\d+)_(.*)/$2\_$1/;
  }
  my $notgarbage = 1;
  if (NOGARBAGE) {
    my %checkhash = ();
    map {$checkhash{$temp[$_]}++ if ($temp[$_] ne "1" && $temp[$_] ne "0.000")} (1..$snp_index-1);
    if (scalar(keys %checkhash) == 0) {
     print STDERR "Detected Garbage Row\n" if DEBUG;
     $notgarbage = 0;
    } 
  }

  if ($temp[$snp_index] && $temp[$snp_index] >= THRESHOLD && $notgarbage && $trimmed_name=~/([A-Z]{3,4}_\d+)_/ ) { #|| $temp[0]=~/SWID_(\d+)_([A-Z]+.\d+)_/)) {
    print STDERR "Registering $temp[0]\n" if DEBUG; 
    $ids{$temp[0]} = $trimmed_name;
    $samples{$ids{$temp[0]}} = {sample=>$1,file=>$temp[0],name=>$trimmed_name}; # register a file as pertaining to a certain sample (studyname_sampleid)
    $sample_counter{$1}++; 

    push(@lines,join("\t",@temp));
  } else {
    $filtered{$temp[0]} = $trimmed_name;
    next;
  }
 } # reading from matrix ends here

 $fh->close;
 print STDERR "Files: ".scalar(keys %ids)." in ".scalar(keys %sample_counter)." samples\n" if DEBUG;

 # Post-filtering: register filtered files as skipped
 # Open a file for writing out filtered matrix (with friendlier file ids):
 my $mfile = $datadir."matrix_filtered.csv";
 $fh->open(">$mfile") or die "Couldn't write filtered data into a file [$mfile]";
 
 my @filterhead;
 
 HEAD:
 foreach my $hf (@heads) {
  if ($filtered{$hf}) {next;}
  push(@filterhead,$hf) if $hf=~/\w+/;
 }
 print STDERR "Filtered header retained ".scalar(@filterhead)." of ".scalar(@heads)." original ones, skipped indexes: ".scalar(keys %filtered)."\n" if DEBUG;

 map{print $fh "\t".$ids{$_} if $ids{$_}} (@filterhead);
 print $fh "\tSNPs\n";
 
 # Get read of filtered files (lines in the matrix)
 LINE:
 foreach my $line (@lines) {
  my @tlines = split("\t",$line);
  if ($line =~/^(\S+)\t/) {
    if ($filtered{$tlines[0]}){next LINE;}
    # TODO a nice point to insert new swap - marking code

    print $fh $ids{$tlines[0]};     # Trimmed  name is printed into matrix_filtered.csv
    my @swapchecks = ();            # Contains coefficients for $heads[$line_idx]
    my @file_ids   = ();            # Contains trimmed names of files corresponding
                                    # to data in @swapchecks 
    IDX:
    foreach my $line_idx (1..$#tlines) {
      if ($filtered{$heads[$line_idx]}) {next IDX;}
       if ($tlines[$line_idx] =~/NA/) {
           print $fh "\t0";
           push(@swapchecks, 0);
       } else {
           print $fh "\t$tlines[$line_idx]";
           push (@swapchecks, $tlines[$line_idx]);
       }
       push(@file_ids, $ids{$heads[$line_idx]});
    }

    my $isSwapped = &flagSwapped($tlines[0], \@filterhead, \@swapchecks);

    $flagged{files}->{$samples{$ids{$tlines[0]}}->{name}}++     if $isSwapped;
    $flagged{samples}->{$samples{$ids{$tlines[0]}}->{sample}}++ if $isSwapped;
    
  } else {
    next LINE;
  }
  print $fh "\n";
  }
  $fh->close;

} else {
 die "No valid matrix file supplied, I cannot continue with no input";
}

# ==============================================
# Using R (heatmap) cluster samples, 
# we need the re-arranged list for next step
# ==============================================

my $ordered      = `Rscript $Bin/cluster.r $datadir/matrix_filtered.csv`;
my @ordered_list = split(" ",$ordered);
print STDERR "Got ".scalar(@ordered_list)." files ordered by clustering\n" if DEBUG;

my %indexed_lines = ();
my %seen_sample   = ();
my %sperslice     = (); # samples per slice, calculate and compare with sample_counter (if no match, there's b/w slices sample split
my %sliced        = ();
my %parent_clusters = (); # keys are samples, values are number of files in the parent cluster
my $count   = 0; # slice counter

map{if(/(\S+)\t/ && $ids{$1}){$indexed_lines{$ids{$1}} = $_}} @lines;
print STDERR "Got ".scalar(keys %indexed_lines)." indexed lines\n" if DEBUG;
my %preclusters = ();
 
# ======================================================================================
# Pre-clustering step, need to re-assign lanes to parent cluster if needed
# pre-clustering results should be used to assemble final clusters for creating heatmaps
# ======================================================================================
my $current_sample;

ORDERED:
foreach my $id (@ordered_list) {
 if (!$samples{$id}) {next ORDERED;}
 if ($sample_counter{$samples{$id}->{sample}} < 2) {
  $filtered{$samples{$id}->{file}} = $samples{$id}->{name}; # Skip all files which are single representatives of their sample
  next ORDERED;
 }
 $current_sample ||=$samples{$id};
 $count++ if ($current_sample ne $samples{$id});

 $preclusters{$count}->{$id}++;
 $sperslice{$count}->{$samples{$id}->{sample}}++;

 if (!$parent_clusters{$samples{$id}->{sample}} || $sperslice{$count}->{$samples{$id}->{sample}} > $parent_clusters{$samples{$id}->{sample}}->{max}) {
         $parent_clusters{$samples{$id}->{sample}} = {max=>$sperslice{$count}->{$samples{$id}->{sample}},cluster=>$count};
 }
}
print STDERR "Found ".scalar(keys %preclusters)." preclusters\n" if DEBUG;

# ============================================================================================
# Re-assign lanes to parent clusters, if needed. Flag those lanes which can not be re-assigned
# Use the results in the next step (composing clusters)
# ============================================================================================
my $headerline = $lines[0];

foreach my $cl (sort {$a<=>$b} keys %preclusters) {
   foreach my $file_id (keys %{$preclusters{$cl}}) {
     if ($parent_clusters{$samples{$file_id}->{sample}}->{cluster}!=$cl) {
         # Retrieve the lines for all files pertaining to the sample 
         my @clines = ($headerline,$indexed_lines{$file_id});
         my @plines = @clines;
         map{push(@plines,$indexed_lines{$_}) if $samples{$_}->{sample} eq $samples{$file_id}->{sample}} (keys %{$preclusters{$parent_clusters{$samples{$file_id}->{sample}}->{cluster}}});
         
         # this may need to be handled differently (perhaps not here, but on the level of R script that build the heatmap)
         if (&aver_ji(\@plines,$samples{$file_id}->{sample},1) >= &aver_ji(\@clines,$samples{$file_id}->{sample},0) - JACCARDOFFSET) {
             # Reassign to parent cluster:
             print STDERR $file_id." gets reassigned to its parent cluster\n" if DEBUG;
             $preclusters{$cl}->{$file_id} = undef;
             $preclusters{$parent_clusters{$samples{$file_id}->{sample}}->{cluster}}->{$file_id}++;
         } else {
             # Flag file and sample
             print STDERR "FOUND split file, putative swap\n" if DEBUG;
             # TODO need to review this under GP-393
             $flagged{files}->{$samples{$file_id}->{name}}++;
             $flagged{samples}->{$samples{$file_id}->{sample}}++;
         }
    }
  }
}

# ============================================================
# Compose slices: Using list from previous step,  
# assemble slices having fewer or 8 samples (final clustering)
# ============================================================

%sperslice = ();
my $slice_id = 0;
PRE:
foreach my $pre (sort {$a<=>$b} keys %preclusters) {
 map{if(!defined($preclusters{$pre}->{$_})){next PRE}} (keys %{$preclusters{$pre}});
 if ($sperslice{$slice_id} && scalar(keys %{$sperslice{$slice_id}}) >= SAMPLESPERSLICE) {
  $slice_id++;
 }

 foreach my $file_id (keys %{$preclusters{$pre}}) {
  $sperslice{$slice_id}->{$samples{$file_id}->{sample}}++;
  $sliced{$slice_id}->{$file_id}++;
 }
}

# =================================================
# Append last cluster to last-1 cluster if there's 
# only one (or two) sample in the last one
# =================================================

if (scalar(keys %{$sperslice{scalar(keys %sliced)-1}}) <= 2 && scalar(keys %sliced) > 1) {
 foreach my $f (keys %{$sliced{scalar(keys %sliced)-1}}) {
  $sliced{scalar(keys %sliced)-1}->{$f} = undef;
  $sliced{scalar(keys %sliced)-2}->{$f}++;
 }
 map {$sperslice{scalar(keys %sliced)-2}->{$_}++} (keys %{$sperslice{scalar(keys %sliced)-1}});
 $sliced{scalar(keys %sliced)-1} = undef;
}

print STDERR Dumper(%flagged) if DEBUG;

# =================================================
# Now print all slices 
# =================================================

foreach my $sl (sort {$a<=>$b} keys %sliced) {
 next if !$sliced{$sl};
 $sperslice{$sl} = {};
 my @slicelines = ($lines[0]);

 foreach my $oid(@ordered_list) {
   next if !$sliced{$sl}->{$oid};
   $sperslice{$sl}->{$samples{$oid}->{sample}}++;
   push(@slicelines,$indexed_lines{$oid}) if $indexed_lines{$oid};
 }
 if (scalar(keys %{$sperslice{$sl}}) == 0){next;} # Skip non-existing clices
 my $t = join(",",(keys %{$sperslice{$sl}})); # Title
 print STDERR "MY TITLE: $t\n" if DEBUG;
 &printout_slice($sliced{$sl},$sl,\@slicelines,join("_",($studyname,$sl)),$datadir,$t);
 &printout_snps($sliced{$sl},$sl,join("_",($studyname,$sl)),$datadir);
}

&printout_html;

# =================================================================
# make HTML report (will call a couple of subroutines)
# =================================================================

# These images are hardcoded, not supposed to be customizable

sub printout_html {

 print start_html(-title=>'Sample Fingerprinting Report',
                  -author=>'pruzanov@oicr.on.ca',
                  -meta=>{'keywords'=>'sample swap detection genotype fingerprinting',
                                      'copyright'=>'&copy; 2013 OICR'},
                  -script=>[{-type  => 'text/javascript',
                             -code  => 'function showFingerprints(snapshot){window.open(snapshot,"_blank","width='.($pngsize + 1).',height=600,toolbar=0,menubar=0,status=1,scrollbars=yes,resizable=1")}'}],
                  -BGCOLOR=>'white');

 print button(-onClick=>"showFingerprints('help.html')",
              -name=>"help_button",
              -value=>"Help");

 print "\n&nbsp;&nbsp;\n";
 my $matrix_link = $matrix;
 $matrix_link=~s!.*/!!;
 print button(-onClick=>"window.location.href=\'$matrix_link\'",
              -name   =>"download_button",
              -value  =>"Download Data");
 print h2("Sample Fingerprinting for ".$studyname." study");
 print br;
 #1. Suspicious samples
 if (scalar(keys %{$flagged{files}}) > 0) {
  my @flagged = map{Tr({-align=>'LEFT',-valign=>'BOTTOM'},td($_))} (keys %{$flagged{files}});

  print h3("Files flagged as potential sample swaps:");
  print br;
  print table({-border=>0},
               @flagged);
}


 #2. Filtered files:
 if (scalar(keys %filtered) > 0) {
  my @filtered = map{Tr({-align=>'LEFT',-valign=>'BOTTOM'},td($_))} (values %filtered);

  print h3("Files skipped due to low coverage/small number of SNPs or single file in a sample:");
  print br;
  print table({-border=>0},
               @filtered);
 }


 # Define table = 3 columns always, rows - depending on the number of heatmaps
 my $n_rows = scalar(keys %reports)/3;
 $n_rows = int($n_rows) < $n_rows ? int($n_rows + 1) : int($n_rows);

 # 3. image of the heatmap and 4. button with a link to popup with fingerprints
 my @hmaps = map {&heatmap_rep($_)} (sort {$a<=>$b} keys %reports);
 my @tab_rows = map {3*$_+2 <= $#hmaps ? Tr({-align=>'LEFT',-valign=>'TOP'},@hmaps[3*$_..3*$_+2])
                                       : Tr({-align=>'LEFT',-valign=>'TOP'},@hmaps[3*$_..$#hmaps]);} (0..$n_rows-1);

 print h3("Heatmaps based on similarity matricies:");
 print table({-border=>0},
              @tab_rows);

 print end_html;
}
#==========================================================================================================================
# A subroutine for printing out genotype report for a heatmap (slice) - will list all SNPs in checked 'hotspots' in a table
#==========================================================================================================================
sub printout_snps {
 my %sliced = %{shift @_};
 my($slice_id,$filecard,$datadir) = @_;

 # Open .fin file and read info from there, build matrix for all files in the slice and print into a file
 my $fh_fin = new IO::File();
 my %snpinfo;
 my %snpcalls;
 my @titles = (); # Cell titles

 foreach my $id (sort keys %sliced) {
  my $finfile = $tempdir.$samples{$id}->{file}.".fin";

  my $file_ok = 1;
  $fh_fin->open($finfile) or $file_ok = 0;
  if (!$file_ok) {
   warn "File with snp info for $id is not available";
   next;
  }
  
  my $first = <$fh_fin>;
  if ($first!~/^CHROM/){next;}

  @titles = split("\t",$first) if !@titles;
  my $filename = $samples{$id}->{file};
  while (<$fh_fin>) {
   chomp;
   my @temp = split("\t");
   $snpinfo{$temp[0]}->{$temp[1]} ||= $temp[2];
   $snpcalls{$temp[2]}->{$samples{$id}->{file}} = $temp[3];
  }
  $fh_fin->close;
 }

 # Having collected all snp calls from the .fin files let's create a genotype report file
 my $fname = join("_",($studyname,$slice_id,"genotype_report_$$.csv"));
 my $fpath = $datadir.$fname;
 $fh_fin->open(">$fpath") or die "Couldn't write genotype report to [$fpath]";
 print $fh_fin join("\t",@titles[0..2]);
 my @fnames = map{$samples{$_}->{name}} (sort keys %sliced);
 print $fh_fin "\t",join("\t",@fnames),"\n";

 foreach my $chrom (sort keys %snpinfo) {
  foreach my $pos (sort {$a<=>$b} keys %{$snpinfo{$chrom}}) {
   print $fh_fin join("\t",($chrom,$pos,$snpinfo{$chrom}->{$pos}));
   foreach my $file_id (sort keys %sliced) {
    $snpcalls{$snpinfo{$chrom}->{$pos}}->{$samples{$file_id}->{file}} ? print $fh_fin "\t".$snpcalls{$snpinfo{$chrom}->{$pos}}->{$samples{$file_id}->{file}} : print $fh_fin "\t"; 
   }
   print $fh_fin "\n";
  }
 }
 $fh_fin->close;
 $reports{$slice_id}->{genotype} = $fname;

}
#===========================================================================================
# process slices with two R scripts - one for heatmap, one for 'barcode'-looking fingerprint
# Here we are printing to two files, slightly different header and file ids
#===========================================================================================
sub printout_slice {
 my %sliced = %{shift @_};
 my $slice_id = shift @_;
 my %colors;
 my @lines  = @{shift @_};
 print STDERR "Got ".scalar(@lines)." lines for cluster $slice_id\n" if DEBUG;
 return if scalar(@lines) <= 1;
 my($filecard,$datadir,$pngtitle,$flagged) = @_;
 $flagged ||="FALSE";

 # Temporary matrix file for a slice
 my $outfile = $datadir.$filecard."_$$.csv";
 my $matname = $filecard."_similarity_matrix_$$.csv";
 my $matfile = $datadir.$matname;
 print STDERR "Writing to the file [$outfile] ".(keys %sliced)." datapoints\n" if DEBUG;
 my $fo = new IO::File(">$outfile") or die "Cannot write to file [$outfile]";
 my $fm = new IO::File(">$matfile") or die "Cannot write to file [$matfile]";
 my $first = shift @lines;
 my @names = split "\t",$first;
 shift @names; # remove 1st (useless) element

 my %indexes;
 my $colcount = 0;
 
 NAME:
 for (my $i = 0; $i < @names; $i++) {
  if ($ids{$names[$i]} && $sliced{$ids{$names[$i]}}) {
   print $fo "\t".$ids{$names[$i]};
   $names[$i]=~s!.*/!!;
   print $fm "\t".$samples{$ids{$names[$i]}}->{name};

   $indexes{$i} = $ids{$names[$i]};
   $colors{$samples{$ids{$names[$i]}}->{sample}} ||= $colors[$colcount++];
  }
 }
 print STDERR "Assigned ".scalar(keys %colors)." colors to clusters\n" if DEBUG;
 print $fo "\tSNPs\tColor\n";
 print $fm "\tSNPs\n";

 # Main body of the matrix:
 foreach (@lines) {
  chomp;
  my @temp = split("\t");
  print $fo $ids{$temp[0]};
  $temp[0]=~s!.*/!!; # remove path, leave the name
  my $col = $colors{$samples{$ids{$temp[0]}}->{sample}};
  print $fm $samples{$ids{$temp[0]}}->{name};
  
  foreach my $idx(sort {$a<=>$b} keys %indexes) {
   if ($temp[$idx + 1] ne "NA") {
      print $fo "\t".$temp[$idx + 1];
      print $fm "\t".$temp[$idx + 1];
   } else {
      print $fo "\t0";
      print $fm "\tNA";
   }
  }

  print $fo "\t".$temp[$snp_index];
  print $fm "\t".$temp[$snp_index];
  print $fo "\t".$col;
  print $fo "\n";
  print $fm "\n";

 }
 $fo->close;
 $fm->close;

 # Produce images
 my $png = $datadir.$filecard.".png";
 print STDERR "Will Rscript $Bin/create_heatmap.r $outfile $pngtitle $refsnps $png $pngsize $flagged\n" if DEBUG;
 my $clustered_ids = `Rscript $Bin/create_heatmap.r $outfile $pngtitle $refsnps $png $pngsize $flagged`;
 my @clustered_ids = grep {/\S+/} split(" ",$clustered_ids); # grep {/$studyname/}
 print STDERR "Clustered IDs:\n" if DEBUG;
 print STDERR Dumper(@clustered_ids) if DEBUG;
 my @fingers = ();
 my %seen_sample = (); # Re-use this hash for calculating
 my %maxfiles = ();    # maximum number of files in a sample (donor) on this heatmap. 'Max' cluster doesn't get marked
 my $current_sample;
 my $lbuffer = [];     # lane buffer - for holding files in a cluster

 # Checking for broken clusters and generating fingerprint glyphs

 for (my $cl = 0; $cl < @clustered_ids; $cl++) { 
  next if $flagged{files}->{$samples{$clustered_ids[$cl]}->{name}};  # Skipping these should prevent marking clusters that have putative swap lanes inserted

  $current_sample ||= $samples{$clustered_ids[$cl]}->{sample};
  $seen_sample{$current_sample} ||= [];
  $maxfiles{$current_sample} ||= 0;
  
  if ($current_sample && $samples{$clustered_ids[$cl]}->{sample} && $current_sample ne $samples{$clustered_ids[$cl]}->{sample}) {
    push(@{$seen_sample{$current_sample}},$lbuffer);
    if ($maxfiles{$current_sample} < scalar(@{$lbuffer})){$maxfiles{$current_sample} = scalar(@{$lbuffer});}
    $lbuffer = [];
    $current_sample = $samples{$clustered_ids[$cl]}->{sample};
  }
  push(@{$lbuffer},$clustered_ids[$cl]);  
  

  ID:
  foreach my $id (keys %ids) {
   if($ids{$id} eq $clustered_ids[$cl]){
    $png = $ids{$id}.".fp".".png";
    push(@fingers,{img=>$png,
                   name=>$samples{$ids{$id}}->{name}});
    $png = $datadir.$png;
    my $fin = $id.".fin";
    $fin =~s!.*/!!;
     print STDERR "Will Rscript $Bin/create_fingerprints.r $tempdir $fin $colors{$samples{$clustered_ids[$cl]}->{sample}} $refsnps $png\n" if DEBUG;
     `Rscript $Bin/create_fingerprints.r $tempdir $fin $colors{$samples{$clustered_ids[$cl]}->{sample}} $refsnps $png`;
    last ID;
   } 
  }
 }

 if (scalar(@{$lbuffer}) > 0) {
  push(@{$seen_sample{$current_sample}},$lbuffer);
  if (!$maxfiles{$current_sample} || $maxfiles{$current_sample} < scalar(@{$lbuffer})){$maxfiles{$current_sample} = scalar(@{$lbuffer});}
 }

 # Updating flagging for files and samples 
 print STDERR Dumper(%seen_sample) if DEBUG;
 foreach my $sample (keys %seen_sample) {
  next if (scalar(@{$seen_sample{$sample}}) <= 1); 
  my $havemax = 0;
  map{if (scalar(@{$_}) == $maxfiles{$sample}){$havemax++}} (@{$seen_sample{$sample}});
  foreach my $clustr(@{$seen_sample{$sample}}) {
   if (scalar(@{$clustr}) < $maxfiles{$sample} || (scalar(@{$clustr}) == $maxfiles{$sample} && $havemax > 1)) {
     # TODO review this under GP-393
     map{$flagged{files}->{$samples{$_}->{name}}++} (@{$clustr});
     $flagged{samples}->{$sample}++;
     $flagged = "TRUE";
   }
  }
 }

 print STDERR Dumper(%flagged) if DEBUG;

 # Register the image name in the report hash
 $reports{$slice_id} = {img=>$filecard.".png",
                        fp=>[@fingers],
                        flagged=>$flagged eq "TRUE" ? "FLAGGED" : "OK",
                        matrix=>$matname,
                        title=>$pngtitle};
}

# ====================================================================================================================
# Average Jaccard index for a set of lines (if sample variable passed, only values for files from the sample processed) 
# ====================================================================================================================
sub aver_ji {
 # If there's no sample, will use all values exept 1 (genotype compared with itself)
 my($lines,$sample,$include) = @_;
 my @values = ();
 my $first = shift @{$lines};
 my @names = grep {/\S+/} split "\t",$first; 

 my %indexes;
 if ($sample) {
  NAME:
  for (my $i = 0; $i < @names; $i++) {
   if ($ids{$names[$i]} && $samples{$ids{$names[$i]}}->{sample} eq $sample) {
    $indexes{$i} = $ids{$names[$i]};
   }              
  }
 }

 foreach my $line (@{$lines}) {
   chomp($line);
   my @temp = split("\t",$line);
   if (%indexes) {
    if ($include) {
     map{if ($temp[$_ + 1] ne "1" && $temp[$_ + 1] ne "NA"){push(@values,$temp[$_ + 1])}} (sort {$a<=>$b} keys %indexes);
    } else {
     map{if (!$indexes{$_} && $temp[$_ + 1]=~/\d+/ && $temp[$_ + 1] ne "1" && $temp[$_ + 1] ne "NA"){push(@values,$temp[$_ + 1])}} (1..($snp_index-2));
    }
   } else {
    map{if ($temp[$_ + 1] ne "1" && $temp[$_ + 1] ne "NA"){push(@values,$temp[$_ + 1])}} (1..($snp_index-2));
   }
 }
 # return average Jaccard index:
 if (scalar(@values) > 0) {
  my $sum = 0;
  map{$sum+=$_} (@values);
  return sprintf "%.1f", $sum/scalar(@values);
 } 
 return 0;
}


# =================================================================
# Creates HTML for a table cell (heatmap, button for opening popup)
# =================================================================

sub heatmap_rep {
 my $heat = shift @_;
 my $link_image = "images/fp_button.png";
 my $sim_image  = "images/sim_button.png";
 my $gen_image  = "images/gen_button.png";

 my $popup = &create_popup($heat,$datadir);

 my @samples = split(",",$reports{$heat}->{title});
 my @labels  = map{$flagged{samples}->{$_} ? br.label({-style=>"color:#f93b08;"},$_) : br.label($_)} @samples;

 return td(img({-src=>$reports{$heat}->{img},
                -width=>500,
                -height=>500,
                -alt=>'Heatmap_'.$heat."_".$reports{$heat}->{flagged}}),br,
           image_button({-src=>$link_image,
                -width=>111,
                -height=>32,
                -alt=>"clickglyph",
                -name=>"fingers_$heat",
                -onClick=>"showFingerprints(\'$popup\')",
                -value=>$heat,
                -align=>'MIDDLE'}),
           a({-href=>$reports{$heat}->{matrix},-target=>'_new'},
           img({-src=>$sim_image,
                -width=>111,
                -height=>32,
                -alt=>"matrix_glyph",
                -name=>"matrix_$heat",
                -value=>$heat,
                -align=>'LEFT'})),
           a({-href=>$reports{$heat}->{genotype},-target=>'_new'},
           img({-src=>$gen_image,
                -width=>111,
                -height=>32,
                -alt=>"genotype_glyph",
                -name=>"genotype_$heat",
                -value=>$heat,
                -align=>'LEFT'})),
           @labels);
}

# ======================================================================================
# Function for writing HTML for a popup (for a cluster #, expects image being available)
# ======================================================================================

sub create_popup {
 my($cluster_id,$dir) = @_;
 if (!$reports{$cluster_id}->{fp}) {
  return "error_popup.html";
 }

 my $popname = "fingerprints_popup_$cluster_id"."_$$".".html";
 my $pop = new IO::File(">$dir/$popname") or die "Cannot write to [>$dir/$popname]";

 print $pop start_html(-title   => "Individual Fingerprints Report $cluster_id",
                       -author  => 'pruzanov@oicr.on.ca',
                       -meta    => {'keywords'=>'sample swap detection genotype fingerprinting',
                                                'copyright'=>'&copy; 2013 OICR'},
                       -BGCOLOR => 'white');

 my @t_rows = ();
 foreach my $finger (@{$reports{$cluster_id}->{fp}}) {
  my $nopath_name = $finger->{name};
  $nopath_name=~s!.*/!!;

  if ($flagged{files}->{$finger->{name}}) {
   push(@t_rows,Tr({-align=>'LEFT', -valign=>'BOTTOM'},(td(img({-src=>$finger->{img},-alt=>'Fingerprint '.$finger->{img}})),
                                                        td({'style'=>"font-size:small; color:#ff0000;"},label($nopath_name)))));
   print STDERR "FLAGGED File found!\n" if DEBUG;
  }else{
   push(@t_rows,Tr({-align=>'LEFT', -valign=>'BOTTOM'},(td(img({-src=>$finger->{img},-alt=>'Fingerprint '.$finger->{img}})),
                                                        td({'style'=>"font-size:small;"},label($nopath_name)))));
  } 
 }

 print $pop table({-border      =>0,
                   -cellpadding =>0,
                   -cellspacing =>0},
                   @t_rows);

 print $pop end_html;
 $pop->close;
 return $popname;
}

=head2 Swap Detection
 
 New-ish swap-marking algorithm that would use filtered header and filtered coefficient
 Headers are sorted according to coefficients and if N of items (files) on the top of 
 the list doesn't match the total N of filtered files, file is marked as swapped.

 Example:
          	GHRT_0001	GHRT_0002	GHRT_0003	BLAH_001	BLAH_002	BLAH_003
 GHRT_0001	0.65	        0.8	        0.6	        0.3	        0.25	        0.14

 
 Sorted, Sample GHRT_0001 is not marked as swapped:

 	        BLAH_003	BLAH_002	BLAH_001	GHRT_0003	GHRT_0002	GHRT_0001
 GHRT_0001	0.14	        0.25	        0.3	        0.6	        0.8	        1


 Sorted, Sample GHRT_0002 marked as swap (related sample are NOT the closest):

 	        GHRT_0001	GHRT_0005	GHRT_0003	BLAH_002	BLAH_001	GHRT_0002
 GHRT_0002	0.12	        0.34	        0.35	        0.45	        0.6	        1


 More complex cases: 

 GHRT_0001 is NOT marked as swap b/c it clusters with other GRHT items and together they rpresent more than 1/2 of all GRHT tems

 	        GHRT_0003	BLAH_003	BLAH_002	BLAH_001	GHRT_0005	GHRT_0002	GHRT_0001
 GHRT_0001	0.1	        0.34	        0.45	        0.5	        0.8	        0.8	        1

 GRHT_0001 IS marked as swap b/c with other GRHT cluster members it is 1/2 of all GRHT items (it is even more certain if 
 there're fewer than 1/2 of all GRHT items stay together)

                GHRT_0003       GHRT_0004	BLAH_003        BLAH_002        BLAH_001        GHRT_0002       GHRT_0001
 GHRT_0001      0.1             0.2	        0.34            0.45            0.5             0.8             1

 
=cut

sub flagSwapped {
 
 my $id    = shift @_;
 my @files = @{shift @_};
 my @data  = @{shift @_};

 # Discard SNP data
 pop(@files);
 pop(@data);

 if (scalar(@files) != scalar(@data)) {die "Couldn't proceed, we have different number of files and data points!";}

 print "I got ID: $id\n";
 print "From this list:\n";
 print join("\n",@files);
 print "\nHaving these data:\n";
 print join ("\t",@data);

 my %coeffs = map {$files[$_]=>$data[$_]} (0..scalar(@data) - 1); 
 my @sorted_coeffs = (reverse sort values %coeffs);
 # Need to know total files for sample S
 # 
  
 #print STDERR Dumper($samples{$ids{$id}});
 #print STDERR Dumper(%coeffs);
 print STDERR Dumper(@sorted_coeffs);

 my $co_clustred = 0;
 foreach my $c (@sorted_coeffs) {
   my $ok2continue = 0;
   map{if ($coeffs{$_} == $c && $samples{$ids{$_}}->{sample} eq $samples{$ids{$id}}->{sample}){$ok2continue = 1}} @files; 
   last if !$ok2continue;
   $co_clustred++;
 }

 exit;


}
