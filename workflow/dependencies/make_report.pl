#!/usr/bin/perl -w

#
# Script for filtering and clustering genotypes, splitting matrix into a set of smaller chunks and producing images 
# + html wrapper
#

use strict;
use Getopt::Long;
use CGI qw/:standard/;
use IO::File;
use Data::Dumper;

use constant THRESHOLD=>30; # That many SNPs every genotype should have
use constant DEBUG=>0;
use constant SAMPLESPERSLICE=>8;

my($datadir,$tempdir,$matrix,$studyname,$refsnps); # external parameters
my($snp_index,%samples,%sample_counter,%ids,%filtered,@lines,%reports); # internal variables

my $pngsize = 750;

# reports (for each slice) should contain these data:
# img => image of the heatmap
# fp  => image of the fingerprints
# title => title that should list all samples in the cluster


my @colors = qw/red orange yellow green lightblue blue purple darkgreen black/; 
my $USAGE="make_report.pl --datadir=[req] --studyname=[req] --matrix=[req]";
my $result = GetOptions ('datadir=s'    => \$datadir, # working (output) directory
                         'tempdir=s'    => \$tempdir,  # directory with temporary GATK files
                         'matrix=s'     => \$matrix,  # file with calculated indexes
                         'refsnps=i'    => \$refsnps, # number of SNPs in reference checkpoint list
                         'studyname=s'  => \$studyname);

# First step -load the data, filter files with not enogh SNPs 
$datadir.="/" if $datadir !~m!/$!;
$tempdir ||=$datadir;

# =====================================================================================
# Reading from the matrix generated by the workflow (csv format, provisioned)
# =====================================================================================
if ($matrix && -e $matrix) {
 my $fh = new IO::File("<$matrix") or die "There was an error reading file [$matrix]";
 my $firstline = <$fh>;
 chomp($firstline);
 my @heads = split("\t",$firstline);
 map {if ($heads[$_]=~/^SNP/){$snp_index = $_}} (0..$#heads);

 $snp_index or die "The matrix file [$matrix] is missing the column with number of SNPs called per genotype";
 @lines = ($firstline);

 # Find what is the index of 'SNPs' column and use it later to remove those entries with fewer than THRESHOLD SNPs
 while (<$fh>) {
  chomp;
  my @temp = split("\t");

  if ($temp[$snp_index] && $temp[$snp_index] >= THRESHOLD && $temp[0]=~/(\d+)_($studyname.\d+)_/) {
    $ids{$temp[0]} = join("_",($2,$1));
    $samples{$ids{$temp[0]}} = {sample=>$2,file=>$temp[0]}; # register a file as pertaining to a certain sample (studyname_sampleid)
    $sample_counter{$2}++; 

    push(@lines,join("\t",@temp));
  } else {
    $filtered{$temp[0]}++;
    next;
  }
 } # reading from matrix ends here

 $fh->close;
 print STDERR "Files: ".scalar(keys %ids)." in ".scalar(keys %sample_counter)." samples\n" if DEBUG;

 # Post-filtering: register filtered files as skipped
 # Open a file for writing out filtered matrix (with friendlier file ids):
 $fh->open(">$datadir/matrix_filtered.csv") or die "Couldn't write filtered data into a file [$datadir/matrix_filtered.csv]";
 
 my @filterhead;
 HEAD:
 foreach my $hf (@heads) {
  if ($filtered{$hf}) {next;}
  push(@filterhead,$hf) if $hf=~/\w+/;
 }
 print STDERR "Filtered header retained ".scalar(@filterhead)." of ".scalar(@heads)." original ones, skipped indexes: ".scalar(keys %filtered)."\n" if DEBUG;

 map{print $fh "\t".$ids{$_} if $ids{$_}} (@filterhead);
 print $fh "\tSNPs\n";
 
 # Get read of filtered files (lines in the matrix)
 LINE:
 foreach my $line (@lines) {
  my @tlines=split("\t",$line);
  if ($line=~/^(\S+)\t/) {
    if ($filtered{$tlines[0]}){next LINE;}
    
    print $fh $ids{$tlines[0]};
    IDX:
    foreach my $line_idx (1..$#tlines) {
      if ($filtered{$heads[$line_idx]}) {next IDX;}
      $tlines[$line_idx] =~/NA/ ? print $fh "\t0" : print $fh "\t$tlines[$line_idx]";
    }
    
  } else {
    next LINE;
  }
  print $fh "\n";
  }
  $fh->close;

} else {
 die "No valid matrix file supplied, I cannot continue with no input";
}

# ==============================================
# Using R (heatmap) cluster samples, 
# we need the re-arranged list for next step
# ==============================================

my $ordered      = `Rscript cluster.r $datadir/matrix_filtered.csv`;
my @ordered_list = split(" ",$ordered);
print STDERR "Got ".scalar(@ordered_list)." files ordered by clustering\n" if DEBUG;

my %indexed_lines = ();
my %seen_sample = ();
my %sliced  = ();
my $count   = 0; # slice counter

map{if(/(\S+)\t/ && $ids{$1}){$indexed_lines{$ids{$1}} = $_}} @lines;
print STDERR "Got ".scalar(keys %indexed_lines)." indexed lines\n" if DEBUG;

# ==============================================
# Compose slices: Using list from previous step,  
# assemble slices having fewer or 8 samples
# ==============================================

ORDERED:
foreach my $id (@ordered_list) {
 if (!$samples{$id}) {next ORDERED;}
 if (scalar(keys %seen_sample) > SAMPLESPERSLICE && $id ne $ordered_list[$#ordered_list]) {
  %seen_sample = ();
  $count++;
 }

 $seen_sample{$samples{$id}->{sample}}++;
 $sliced{$count}->{$id}++;
}
# Flag suspicios slices here:===============================================================
%seen_sample = (); # Re-use this hash for calculating 
my %flagged_slices = (); # Register slice # (keys) and affected samples (values)
my %sperslice = (); # samples per slice, calculate and compare with sample_counter (if no match, there's b/w slices sample split

# ===============================================
# internal mixup detection
# ===============================================

SLICE:
foreach my $slice (keys %sliced) {
 my $current = "";
 ORD:
 foreach my $oid(@ordered_list) {
   if (!$sliced{$slice}->{$oid}){next ORD;}
   $current ||= $samples{$oid}->{sample};
   $sperslice{$slice}->{$samples{$oid}->{sample}}++;
   if ($samples{$oid}->{sample} ne $current) {
    $seen_sample{$current}++;
    if ($seen_sample{$current} > 1) {
     $flagged_slices{$slice}->{$current}++;
    }
    $current = $samples{$oid}->{sample};
   }
 }
 map{if($sperslice{$slice}->{$_} < $sample_counter{$_}){$flagged_slices{$slice}->{$_}++}} (keys %{$sperslice{$slice}});
}

# =================================================
# Now print all slices 
# =================================================

foreach my $sl (sort {$a<=>$b} keys %sliced) {
 my $t = join(",",(keys %{$sperslice{$sl}})); # Title
 my @slicelines = ($lines[0]);

 foreach my $oid(@ordered_list) {
   next if !$sliced{$sl}->{$oid};
   push(@slicelines,$indexed_lines{$oid}) if $indexed_lines{$oid};
 }
 
 $flagged_slices{$sl} ? &printout_slice($sliced{$sl},$sl,\@slicelines,join("_",($studyname,$sl)),$datadir,$t,"TRUE") 
                      : &printout_slice($sliced{$sl},$sl,\@slicelines,join("_",($studyname,$sl)),$datadir,$t,"FALSE");
}

#===========================================================================================
# process slices with two R scripts - one for heatmap, one for 'barcode'-looking fingerprint
#===========================================================================================
sub printout_slice {
 my %sliced = %{shift @_};
 my $slice_id = shift @_;
 my %colors;
 my @lines  = @{shift @_};
 print STDERR "Got ".scalar(@lines)." lines for cluster $slice_id\n" if DEBUG;
 my($filecard,$datadir,$pngtitle,$flagged) = @_;

 # Temporary matrix file for a slice
 my $outfile = $datadir.$filecard.".csv";
 print STDERR "Writing to the file [$outfile] ".(keys %sliced)." datapoints\n" if DEBUG;
 my $fo = new IO::File(">$outfile") or die "Cannot write to file [$outfile]";
 my $first = shift @lines;
 my @names = split "\t",$first;
 
 
 shift @names; # remove 1st (useless) element

 my %indexes;
 my $colcount = 0;
 NAME:
 for (my $i = 0; $i < @names; $i++) {
  if ($ids{$names[$i]} && $sliced{$ids{$names[$i]}}) {
   print $fo "\t".$ids{$names[$i]};
   $indexes{$i} = $ids{$names[$i]};
   $colors{$samples{$ids{$names[$i]}}->{sample}} ||= $colors[$colcount++];
  }
 }
 print STDERR "Assigned ".scalar(keys %colors)." colors to clusters\n" if DEBUG;
 print $fo "\tSNPs\tColor\n";

 # Main body of the matrix:
 foreach (@lines) {
  chomp;
  my @temp = split("\t");

  print $fo $ids{$temp[0]};
  map{$temp[$_ + 1] ne "NA" ? print $fo "\t".$temp[$_ + 1] : print $fo "\t0"} (sort {$a<=>$b} keys %indexes);
  print $fo "\t".$temp[$snp_index];
  print $fo "\t".$colors{$samples{$ids{$temp[0]}}->{sample}};
  print $fo "\n";

 }
 $fo->close;

 # Produce images
 my $png = $datadir.$filecard.".png";
 print STDERR "Will Rscript create_heatmap.r $outfile $pngtitle $refsnps $png $pngsize $flagged\n" if DEBUG;
 my $clustered_ids = `Rscript create_heatmap.r $outfile $pngtitle $refsnps $png $pngsize $flagged`;
 my @clustered_ids = split(" ",$clustered_ids);
 
 my @fingers = ();
 for (my $cl = 0; $cl < @clustered_ids; $cl++) {
  foreach my $id (keys %ids) {
   if($ids{$id} eq $clustered_ids[$cl]){
    $png = $datadir.$filecard.".fp.".$cl."png";
    push(@fingers,{img=>$png,
                   name=>$id});
    my $fin = $id.".fin";
    print STDERR "Will Rscript create_fingerprints.r $tempdir $fin $colors{$samples{$clustered_ids[$cl]}->{sample}} $refsnps $png\n" if DEBUG;
    `Rscript create_fingerprints.r $tempdir $fin $colors{$samples{$clustered_ids[$cl]}->{sample}} $refsnps $png`;
   } 
  }
 }

 # Register the image name in the report hash
# my $flag = $flagged eq "TRUE" ? "FLAGGED" : "OK";
 $reports{$slice_id} = {img=>$filecard.".png",
                        fp=>[@fingers],
                        flagged=>$flagged eq "TRUE" ? "FLAGGED" : "OK",
                        title=>$pngtitle};
}

# =================================================================
# make HTML report (will call a couple of subroutines)
# =================================================================

my $link_image = "images/fp_button.jpg";
print start_html(-title=>'Sample Fingerprinting Report',
                 -author=>'pruzanov@oicr.on.ca',
                 -meta=>{'keywords'=>'sample swap detection genotype fingerprinting',
                                     'copyright'=>'&copy; 2013 OICR'},
                 -script=>[{-type => 'text/javascript',
                           -code  => 'function showFingerprints(snapshot){window.open(snapshot,"fingerprints","width='.($pngsize + 1).',height=600,toolbar=0,menubar=0,status=1,scrollbars=yes,resizable=1")}'}],
                 -BGCOLOR=>'white');
print h2("Sample Fingerprinting for ".$studyname." study");
print br;

# Define table = 3 columns always, rows - depending on the number of heatmaps
my $n_rows = scalar(keys %reports)/3;
$n_rows = int($n_rows) < $n_rows ? int($n_rows + 1) : int($n_rows);

print STDERR "N rows: ".$n_rows."\n" if DEBUG;
# 1. image of the heatmap and 2. button with a link to popup with fingerprints
my @hmaps = map {&heatmap_rep($_)} (sort {$a<=>$b} keys %reports);
my @tab_rows = map {$_+2 == $#hmaps ? Tr({-align=>'LEFT',-valign=>'BOTTOM'},@hmaps[$_..$_+2])
                                    : Tr({-align=>'LEFT',-valign=>'BOTTOM'},@hmaps[$_..$#hmaps]);} (0..$n_rows-1);

print table({-border=>0},
            @tab_rows);

# 3. Filtered files:
if (scalar(keys %filtered) > 0) {
 my @filtered = map{Tr({-align=>'LEFT',-valign=>'BOTTOM'},td($_))} (keys %filtered);

 print h3("Files skipped due to low coverage/small number of SNPs at control loci:");
 print br;
 print table({-border=>0},
              @filtered);
}

print end_html;

# =================================================================
# Creates HTML for a table cell (heatmap, button for opening popup)
# =================================================================

sub heatmap_rep {
 my $heat = shift @_;
 
 my $popup = &create_popup($_,$datadir);

 return td(img({-src=>$reports{$heat}->{img},
                -width=>500,
                -height=>500,
                -alt=>'Heatmap_'.$heat."_".$reports{$heat}->{flagged}}),br,
           image_button({-src=>$link_image,
                -width=>111,
                -height=>32,
                -alt=>"clickglyph",
                -name=>'button_name',
                -onClick=>"showFingerprints(\'$popup\')",
                -value=>$heat,
                -align=>'MIDDLE'}),
           h6($reports{$heat}->{title}));
}

# ======================================================================================
# Function for writing HTML for a popup (for a cluster #, expects image being available)
# ======================================================================================

sub create_popup {
 my($cluster_id,$dir) = @_;
 if (!$reports{$cluster_id}->{fp}) {
  return "error_popup.html";
 }

 my $popname = "fingerprints_popup$cluster_id.html";
 my $pop = new IO::File(">$dir/$popname") or die "Cannot write to [>$dir/$popname]";

 print $pop start_html(-title=>"Individual Fingerprints Report $cluster_id",
                 -author=>'pruzanov@oicr.on.ca',
                 -meta=>{'keywords'=>'sample swap detection genotype fingerprinting',
                                     'copyright'=>'&copy; 2013 OICR'},
                 -BGCOLOR=>'white');

 my @t_rows = map {Tr({-align=>'LEFT', -valign=>'BOTTOM'},(td(img({-src=>$_->{img},-alt=>'Fingerprint '.$_->{img}})),
                                                           td({'style'=>"font-size:small"},label($_->{name}))))} (@{$reports{$cluster_id}->{fp}});
 print $pop table({-border=>0,
                   -cellpadding=>0,
                   -cellspacing=>0},
                   @t_rows);

 print $pop end_html;
 $pop->close;
 return $popname;
}
