#!/usr/bin/perl -w

# =================================================================================================================
# Script for filtering and clustering genotypes, splitting matrix into a set of smaller chunks and producing images 
# + html wrapper
# =================================================================================================================

use strict;
use Getopt::Long;
use CGI qw/:standard/;
use IO::File;
use Data::Dumper;

use constant THRESHOLD=>30; # That many SNPs every genotype should have
use constant DEBUG=>0;
use constant SAMPLESPERSLICE=>8;
use constant JACCARDOFFSET=>0.1; # Allow files to be reassigned to their parent cluster if they similarity to external files is not that great

my($datadir,$tempdir,$matrix,$studyname,$refsnps); # external parameters
my($snp_index,%samples,%sample_counter,%ids,%filtered,@lines,%reports,%flagged); # internal variables

# %flagged structure: %flagged = (samples=>{} slices=>{} files=>{}) multiple levels of flagging
%flagged = (samples=>{}, slices=>{}, files=>{});

my $pngsize = 750;

# reports (for each slice) should contain these data:
# img => image of the heatmap
# fp  => image of the fingerprints
# title => title that should list all samples in the cluster
# matrix => path to file with similarity matrix (jaccard indexes) for a heatmap
# genotype => path to file with genotype info for a heatmap

my @colors = qw/red orange yellow green lightblue blue purple darkgreen black/; 
my $USAGE="make_report.pl --datadir=[req] --studyname=[req] --matrix=[req] --refsnps=[req] --tempdir=[opt]";
my $result = GetOptions ('datadir=s'    => \$datadir, # working (output) directory
                         'tempdir=s'    => \$tempdir,  # directory with temporary GATK files
                         'matrix=s'     => \$matrix,  # file with calculated indexes
                         'refsnps=i'    => \$refsnps, # number of SNPs in reference checkpoint list
                         'studyname=s'  => \$studyname);

# First step -load the data, filter files with not enogh SNPs 
$datadir.="/" if $datadir !~m!/$!;
$tempdir ||=$datadir;
$tempdir.="/" if $tempdir !~m!/$!;

# =====================================================================================
# Reading from the matrix generated by the workflow (csv format, provisioned)
# =====================================================================================
if ($matrix && -e $matrix) {
 my $fh = new IO::File("<$matrix") or die "There was an error reading file [$matrix]";
 my $firstline = <$fh>;
 chomp($firstline);
 my @heads = split("\t",$firstline);
 map {if ($heads[$_]=~/^SNP/){$snp_index = $_}} (0..$#heads);

 $snp_index or die "The matrix file [$matrix] is missing the column with number of SNPs called per genotype";
 @lines = ($firstline);

 # Find what is the index of 'SNPs' column and use it later to remove those entries with fewer than THRESHOLD SNPs
 while (<$fh>) {
  chomp;
  my @temp = split("\t");

  if ($temp[$snp_index] && $temp[$snp_index] >= THRESHOLD && $temp[0]=~/(\d+)_($studyname.\d+)_/) {
    $ids{$temp[0]} = join("_",($2,$1));
    $samples{$ids{$temp[0]}} = {sample=>$2,file=>$temp[0]}; # register a file as pertaining to a certain sample (studyname_sampleid)
    $sample_counter{$2}++; 

    push(@lines,join("\t",@temp));
  } else {
    $filtered{$temp[0]}++;
    next;
  }
 } # reading from matrix ends here

 $fh->close;
 print STDERR "Files: ".scalar(keys %ids)." in ".scalar(keys %sample_counter)." samples\n" if DEBUG;

 # Post-filtering: register filtered files as skipped
 # Open a file for writing out filtered matrix (with friendlier file ids):
 my $mfile = $datadir."matrix_filtered.csv";
 $fh->open(">$mfile") or die "Couldn't write filtered data into a file [$mfile]";
 
 my @filterhead;
 HEAD:
 foreach my $hf (@heads) {
  if ($filtered{$hf}) {next;}
  push(@filterhead,$hf) if $hf=~/\w+/;
 }
 print STDERR "Filtered header retained ".scalar(@filterhead)." of ".scalar(@heads)." original ones, skipped indexes: ".scalar(keys %filtered)."\n" if DEBUG;

 map{print $fh "\t".$ids{$_} if $ids{$_}} (@filterhead);
 print $fh "\tSNPs\n";
 
 # Get read of filtered files (lines in the matrix)
 LINE:
 foreach my $line (@lines) {
  my @tlines=split("\t",$line);
  if ($line=~/^(\S+)\t/) {
    if ($filtered{$tlines[0]}){next LINE;}
    
    print $fh $ids{$tlines[0]};
    IDX:
    foreach my $line_idx (1..$#tlines) {
      if ($filtered{$heads[$line_idx]}) {next IDX;}
      $tlines[$line_idx] =~/NA/ ? print $fh "\t0" : print $fh "\t$tlines[$line_idx]";
    }
    
  } else {
    next LINE;
  }
  print $fh "\n";
  }
  $fh->close;

} else {
 die "No valid matrix file supplied, I cannot continue with no input";
}

# ==============================================
# Using R (heatmap) cluster samples, 
# we need the re-arranged list for next step
# ==============================================

my $ordered      = `Rscript cluster.r $datadir/matrix_filtered.csv`;
my @ordered_list = split(" ",$ordered);
print STDERR "Got ".scalar(@ordered_list)." files ordered by clustering\n" if DEBUG;

my %indexed_lines = ();
my %seen_sample = ();
my %sperslice = (); # samples per slice, calculate and compare with sample_counter (if no match, there's b/w slices sample split
my %sliced  = ();
my %parent_clusters = (); # keys are samples, values are number of files in the parent cluster
my $count   = 0; # slice counter

map{if(/(\S+)\t/ && $ids{$1}){$indexed_lines{$ids{$1}} = $_}} @lines;
print STDERR "Got ".scalar(keys %indexed_lines)." indexed lines\n" if DEBUG;

# ==============================================
# Compose slices: Using list from previous step,  
# assemble slices having fewer or 8 samples (preliminary clustering)
# ==============================================

ORDERED:
foreach my $id (@ordered_list) {
 if (!$samples{$id}) {next ORDERED;}
 if ($sample_counter{$samples{$id}->{sample}} < 2) {
  $filtered{$samples{$id}->{file}}++; # Skip all files which are single representatives of their sample
  next ORDERED;
 }
 if (scalar(keys %seen_sample) >= SAMPLESPERSLICE && $id ne $ordered_list[$#ordered_list]) {
  %seen_sample = ();
  $count++;
 }

 $seen_sample{$samples{$id}->{sample}}++;
 $sliced{$count}->{$id}++;
 $sperslice{$count}->{$samples{$id}->{sample}}++;
 $parent_clusters{$samples{$id}->{sample}} ||= {max=>$sperslice{$count}->{$samples{$id}->{sample}},cluster=>$count};
 
 if ($sperslice{$count}->{$samples{$id}->{sample}} > $parent_clusters{$samples{$id}->{sample}}->{max}) {
         $parent_clusters{$samples{$id}->{sample}} = {max=>$sperslice{$count}->{$samples{$id}->{sample}},cluster=>$count};
 }
}

# Flag suspicios slices here:===============================================================
# internal mixup detection (secondary clustering, reassigning files)
# ==========================================================================================
# 1. Identify suspects (files)
# 2. retrieve average jaccard indexes for suspects (parent cluster vs new cluster)
# 3. reassign if needed or flag
# ==========================================================================================
my $headerline = $lines[0];

foreach my $cl (sort {$a<=>$b} keys %sliced) {
   foreach my $file_id (keys %{$sliced{$cl}}) {
     if ($parent_clusters{$samples{$file_id}->{sample}}->{cluster}!=$cl) {
         # Retrieve the lines for all files pertaining to the sample 
         my @clines = ($headerline,$indexed_lines{$file_id});
         my @plines = @clines;
         map{push(@plines,$indexed_lines{$_}) if $samples{$_}->{sample} eq $samples{$file_id}->{sample}} (keys %{$sliced{$parent_clusters{$samples{$file_id}->{sample}}->{cluster}}});
         
         if (&aver_ji(\@plines,$samples{$file_id}->{sample},1) >= &aver_ji(\@clines,$samples{$file_id}->{sample},0) - JACCARDOFFSET) {
             # Reassign to parent cluster:
             print STDERR $file_id." gets reassigned to its parent cluster\n" if DEBUG;
             $sliced{$cl}->{$file_id} = undef;
             $sliced{$parent_clusters{$samples{$file_id}->{sample}}->{cluster}}->{$file_id}++;
         } else {
             # Flag slice, file and sample
             $flagged{slices}->{$cl}++;
             $flagged{files}->{$samples{$file_id}->{file}}++;
             $flagged{samples}->{$samples{$file_id}->{sample}}++;
         }
    }
  }
}

# Append last cluster to last-1 cluster if there's only one sample in the last one
# TODO: clusters nedd to be re-assembled after reassigning step
my %samples_last = ();
my $last_sample;
map{$samples_last{$samples{$_}->{sample}}++;$last_sample = $samples{$_}->{sample};} (keys %{$sliced{scalar(keys %sliced)-1}});
if (scalar(keys %samples_last) < 2 && scalar(keys %sliced) > 1) {
 foreach my $f (keys %{$sliced{scalar(keys %sliced)-1}}) {
  $sliced{scalar(keys %sliced)-1}->{$f} = undef;
  $sliced{scalar(keys %sliced)-2}->{$f}++;
  if ($flagged{slices}->{scalar(keys %sliced)-1}) {
    $flagged{slices}->{scalar(keys %sliced)-2}++;
    $flagged{slices}->{scalar(keys %sliced)-1} = undef;
  }
 }
 $sperslice{scalar(keys %sliced)-2}->{$last_sample}++;
 $sliced{scalar(keys %sliced)-1} = undef;
}
print STDERR Dumper(%flagged) if DEBUG;

# =================================================
# Now print all slices 
# =================================================

foreach my $sl (sort {$a<=>$b} keys %sliced) {
 next if !$sliced{$sl};
 $sperslice{$sl} = {};
 my @slicelines = ($lines[0]);

 foreach my $oid(@ordered_list) {
   next if !$sliced{$sl}->{$oid};
   $sperslice{$sl}->{$samples{$oid}->{sample}}++;
   push(@slicelines,$indexed_lines{$oid}) if $indexed_lines{$oid};
 }
 if (scalar(keys %{$sperslice{$sl}}) == 0){next;} # Skip non-existing clices
 my $t = join(",",(keys %{$sperslice{$sl}})); # Title
 print STDERR "MY TITLE: $t\n" if DEBUG;
 
 $flagged{slices}->{$sl} ? &printout_slice($sliced{$sl},$sl,\@slicelines,join("_",($studyname,$sl)),$datadir,$t,"TRUE") 
                         : &printout_slice($sliced{$sl},$sl,\@slicelines,join("_",($studyname,$sl)),$datadir,$t,"FALSE");
 &printout_snps($sliced{$sl},$sl,join("_",($studyname,$sl)),$datadir);
}

# =================================================================
# make HTML report (will call a couple of subroutines)
# =================================================================

# These images are hardcoded, not supposed to be customizable

my $link_image = "images/fp_button.png";
my $sim_image  = "images/sim_button.png";
my $gen_image  = "images/gen_button.png";

print start_html(-title=>'Sample Fingerprinting Report',
                 -author=>'pruzanov@oicr.on.ca',
                 -meta=>{'keywords'=>'sample swap detection genotype fingerprinting',
                                     'copyright'=>'&copy; 2013 OICR'},
                 -script=>[{-type => 'text/javascript',
                           -code  => 'function showFingerprints(snapshot){window.open(snapshot,"_blank","width='.($pngsize + 1).',height=600,toolbar=0,menubar=0,status=1,scrollbars=yes,resizable=1")}'}],
                 -BGCOLOR=>'white');
print button(-onClick=>"showFingerprints('help.html')",
             -name=>"help_button",
             -value=>"Help");
print "\n&nbsp;&nbsp;\n";
my $matrix_link = $matrix;
$matrix_link=~s!.*/!!;
print button(-onClick=>"window.location.href=\'$matrix_link\'",
             -name=>"download_button",
             -value=>"Download Data");
print h2("Sample Fingerprinting for ".$studyname." study");
print br;
#1. Suspicious samples
if (scalar(keys %{$flagged{files}}) > 0) {
 my @flagged = map{Tr({-align=>'LEFT',-valign=>'BOTTOM'},td($_))} (keys %{$flagged{files}});

 print h3("Files flagged as potential sample swaps:");
 print br;
 print table({-border=>0},
              @flagged);
}


#2. Filtered files:
if (scalar(keys %filtered) > 0) {
 my @filtered = map{Tr({-align=>'LEFT',-valign=>'BOTTOM'},td($_))} (keys %filtered);

 print h3("Files skipped due to low coverage/small number of SNPs or single file in a sample:");
 print br;
 print table({-border=>0},
              @filtered);
}


# Define table = 3 columns always, rows - depending on the number of heatmaps
my $n_rows = scalar(keys %reports)/3;
$n_rows = int($n_rows) < $n_rows ? int($n_rows + 1) : int($n_rows);

# 3. image of the heatmap and 4. button with a link to popup with fingerprints
my @hmaps = map {&heatmap_rep($_)} (sort {$a<=>$b} keys %reports);
my @tab_rows = map {3*$_+2 <= $#hmaps ? Tr({-align=>'LEFT',-valign=>'TOP'},@hmaps[3*$_..3*$_+2])
                                      : Tr({-align=>'LEFT',-valign=>'TOP'},@hmaps[3*$_..$#hmaps]);} (0..$n_rows-1);

print h3("Heatmaps based on similarity matricies:");
print table({-border=>0},
            @tab_rows);

print end_html;

#==========================================================================================================================
# A subroutine for printing out genotype report for a heatmap (slice) - will list all SNPs in checked 'hotspots' in a table
#==========================================================================================================================
sub printout_snps {
 my %sliced = %{shift @_};
 my($slice_id,$filecard,$datadir) = @_;

 # Open .fin file and read info from there, build matrix for all files in the slice and print into a file
 my $fh_fin = new IO::File();
 my %snpinfo;
 my %snpcalls;
 my @titles = (); # Cell titles

 foreach my $id (sort keys %sliced) {
  my $finfile = $tempdir.$samples{$id}->{file}.".fin";

  $fh_fin->open($finfile) or warn "File with snp info for $id is not available";
  my $first = <$fh_fin>;
  if ($first!~/^CHROM/){next;}

  @titles = split("\t",$first) if !@titles;
  my $filename = $samples{$id}->{file};
  while (<$fh_fin>) {
   chomp;
   my @temp = split("\t");
   $snpinfo{$temp[0]}->{$temp[1]} ||= $temp[2];
   $snpcalls{$temp[2]}->{$samples{$id}->{file}} = $temp[3];
   
  }
  $fh_fin->close;
 }

 # Having collected all snp calls from the .fin files let's create a genotype report file
 my $fname = $datadir.join("_",($studyname,$slice_id,"genotype_report.csv"));
 $fh_fin->open(">$fname") or die "Couldn't write genotype report to [$fname]";
 print $fh_fin join("\t",@titles[0..2]);
 map{print $fh_fin "\t".$samples{$_}->{file}} (sort keys %sliced);
 print $fh_fin "\n";

 foreach my $chrom (sort keys %snpinfo) {
  foreach my $pos (sort {$a<=>$b} keys %{$snpinfo{$chrom}}) {
   print $fh_fin join("\t",($chrom,$pos,$snpinfo{$chrom}->{$pos}));
   foreach my $file_id (sort keys %sliced) {
    print $fh_fin "\t".$snpcalls{$snpinfo{$chrom}->{$pos}}->{$samples{$file_id}->{file}}; 
   }
   print $fh_fin "\n";
  }
 }
 $fh_fin->close;
 $reports{$slice_id}->{genotype} = $fname;

}
#===========================================================================================
# process slices with two R scripts - one for heatmap, one for 'barcode'-looking fingerprint
# Here we are printing to two files, slightly different header and file ids
#===========================================================================================
sub printout_slice {
 my %sliced = %{shift @_};
 my $slice_id = shift @_;
 my %colors;
 my @lines  = @{shift @_};
 print STDERR "Got ".scalar(@lines)." lines for cluster $slice_id\n" if DEBUG;
 return if scalar(@lines) <= 1;
 my($filecard,$datadir,$pngtitle,$flagged) = @_;

 # Temporary matrix file for a slice
 my $outfile = $datadir.$filecard.".csv";
 my $matfile = $datadir.$filecard."_similarity_matrix.csv";
 print STDERR "Writing to the file [$outfile] ".(keys %sliced)." datapoints\n" if DEBUG;
 my $fo = new IO::File(">$outfile") or die "Cannot write to file [$outfile]";
 my $fm = new IO::File(">$matfile") or die "Cannot write to file [$matfile]";
 my $first = shift @lines;
 my @names = split "\t",$first;
 
 shift @names; # remove 1st (useless) element

 my %indexes;
 my $colcount = 0;
 NAME:
 for (my $i = 0; $i < @names; $i++) {
  if ($ids{$names[$i]} && $sliced{$ids{$names[$i]}}) {
   print $fo "\t".$ids{$names[$i]};
   $names[$i]=~s!.*/!!;
   print $fm "\t".$names[$i];

   $indexes{$i} = $ids{$names[$i]};
   $colors{$samples{$ids{$names[$i]}}->{sample}} ||= $colors[$colcount++];
  }
 }
 print STDERR "Assigned ".scalar(keys %colors)." colors to clusters\n" if DEBUG;
 print $fo "\tSNPs\tColor\n";
 print $fm "\tSNPs\n";

 # Main body of the matrix:
 foreach (@lines) {
  chomp;
  my @temp = split("\t");
  print $fo $ids{$temp[0]};
  $temp[0]=~s!.*/!!; # remove path, leave the name
  print $fm $temp[0];
  
  foreach my $idx(sort {$a<=>$b} keys %indexes) {
   if ($temp[$idx + 1] ne "NA") {
      print $fo "\t".$temp[$idx + 1];
      print $fm "\t".$temp[$idx + 1];
   } else {
      print $fo "\t0";
      print $fm "\tNA";
   }
  }

  print $fo "\t".$temp[$snp_index];
  print $fm "\t".$temp[$snp_index];
  print $fo "\t".$colors{$samples{$ids{$temp[0]}}->{sample}};
  print $fo "\n";
  print $fm "\n";

 }
 $fo->close;
 $fm->close;

 # Produce images
 my $png = $datadir.$filecard.".png";
 print STDERR "Will Rscript create_heatmap.r $outfile $pngtitle $refsnps $png $pngsize $flagged\n" if DEBUG;
 my $clustered_ids = `Rscript create_heatmap.r $outfile $pngtitle $refsnps $png $pngsize $flagged`;
 my @clustered_ids = split(" ",$clustered_ids);
 
 my @fingers = ();
 my %seen_sample = (); # Re-use this hash for calculating
 my $current_sample;

 for (my $cl = 0; $cl < @clustered_ids; $cl++) {
  if ($current_sample && $samples{$clustered_ids[$cl]}->{sample} && $current_sample ne $samples{$clustered_ids[$cl]}->{sample}) {
    $seen_sample{$current_sample}++;
    $current_sample = $samples{$clustered_ids[$cl]}->{sample};
  } else {
    $current_sample = $samples{$clustered_ids[$cl]}->{sample};
  }
  foreach my $id (keys %ids) {
   if($ids{$id} eq $clustered_ids[$cl]){
    $png = $datadir.$filecard.".fp.".$cl.".png";
    push(@fingers,{img=>$png,
                   name=>$id});
    my $fin = $id.".fin";
    $fin =~s!.*/!!;
    print STDERR "Will Rscript create_fingerprints.r $tempdir $fin $colors{$samples{$clustered_ids[$cl]}->{sample}} $refsnps $png\n" if DEBUG;
    `Rscript create_fingerprints.r $tempdir $fin $colors{$samples{$clustered_ids[$cl]}->{sample}} $refsnps $png`;
   } 
  }
 }

 map {if ($seen_sample{$_} > 1){$flagged{slices}->{$slice_id}++;$flagged{samples}->{$_}++;}} (keys %seen_sample);
 # Register the image name in the report hash
 $reports{$slice_id} = {img=>$filecard.".png",
                        fp=>[@fingers],
                        flagged=>$flagged eq "TRUE" ? "FLAGGED" : "OK",
                        matrix=>$matfile,
                        title=>$pngtitle};
}

# ====================================================================================================================
# Average Jaccard index for a set of lines (if sample variable passed, only values for files from the sample processed) 
# ====================================================================================================================
sub aver_ji {
 # If there's no sample, will use all values exept 1 (genotype compared with itself)
 my($lines,$sample,$include) = @_;
 my @values = ();
 my $first = shift @{$lines};
 my @names = grep {/\S+/} split "\t",$first; 
 #shift @names; # remove 1st (useless) element

 my %indexes;
 if ($sample) {
  NAME:
  for (my $i = 0; $i < @names; $i++) {
   if ($ids{$names[$i]} && $samples{$ids{$names[$i]}}->{sample} eq $sample) {
    $indexes{$i} = $ids{$names[$i]};
   }              
  }
 }

 foreach my $line (@{$lines}) {
   chomp($line);
   my @temp = split("\t",$line);
   if (%indexes) {
    if ($include) {
     map{if ($temp[$_ + 1] ne "1" && $temp[$_ + 1] ne "NA"){push(@values,$temp[$_ + 1])}} (sort {$a<=>$b} keys %indexes);
    } else {
     map{if (!$indexes{$_} && $temp[$_ + 1]=~/\d+/ && $temp[$_ + 1] ne "1" && $temp[$_ + 1] ne "NA"){push(@values,$temp[$_ + 1])}} (1..($snp_index-2));
    }
   } else {
    map{if ($temp[$_ + 1] ne "1" && $temp[$_ + 1] ne "NA"){push(@values,$temp[$_ + 1])}} (1..($snp_index-2));
   }
 }
 # return average Jaccard index:
 if (scalar(@values) > 0) {
  my $sum = 0;
  map{$sum+=$_} (@values);
  return sprintf "%.1f", $sum/scalar(@values);
 } 
 return 0;
}


# =================================================================
# Creates HTML for a table cell (heatmap, button for opening popup)
# =================================================================

sub heatmap_rep {
 my $heat = shift @_;
 
 my $popup = &create_popup($heat,$datadir);

 my @samples = split(",",$reports{$heat}->{title});
 my @labels  = map{$flagged{samples}->{$_} ? br.label({-style=>"color:#f93b08;"},$_) : br.label($_)} @samples;

 return td(img({-src=>$reports{$heat}->{img},
                -width=>500,
                -height=>500,
                -alt=>'Heatmap_'.$heat."_".$reports{$heat}->{flagged}}),br,
           image_button({-src=>$link_image,
                -width=>111,
                -height=>32,
                -alt=>"clickglyph",
                -name=>"fingers_$heat",
                -onClick=>"showFingerprints(\'$popup\')",
                -value=>$heat,
                -align=>'MIDDLE'}),
           a({-href=>$reports{$heat}->{matrix},-target=>'_new'},
           img({-src=>$sim_image,
                -width=>111,
                -height=>32,
                -alt=>"matrix_glyph",
                -name=>"matrix_$heat",
                -value=>$heat,
                -align=>'LEFT'})),
           a({-href=>$reports{$heat}->{genotype},-target=>'_new'},
           img({-src=>$gen_image,
                -width=>111,
                -height=>32,
                -alt=>"genotype_glyph",
                -name=>"genotype_$heat",
                -value=>$heat,
                -align=>'LEFT'})),
           @labels);
}

# ======================================================================================
# Function for writing HTML for a popup (for a cluster #, expects image being available)
# ======================================================================================

sub create_popup {
 my($cluster_id,$dir) = @_;
 if (!$reports{$cluster_id}->{fp}) {
  return "error_popup.html";
 }

 my $popname = "fingerprints_popup$cluster_id.html";
 my $pop = new IO::File(">$dir/$popname") or die "Cannot write to [>$dir/$popname]";

 print $pop start_html(-title=>"Individual Fingerprints Report $cluster_id",
                 -author=>'pruzanov@oicr.on.ca',
                 -meta=>{'keywords'=>'sample swap detection genotype fingerprinting',
                                     'copyright'=>'&copy; 2013 OICR'},
                 -BGCOLOR=>'white');

 my @t_rows = ();
 foreach my $finger (@{$reports{$cluster_id}->{fp}}) {
  my $nopath_name = $finger->{name};
  $nopath_name=~s!.*/!!;

  if ($flagged{files}->{$finger->{name}}) {
   push(@t_rows,Tr({-align=>'LEFT', -valign=>'BOTTOM'},(td(img({-src=>$finger->{img},-alt=>'Fingerprint '.$finger->{img}})),
                                                        td({'style'=>"font-size:small; color:#ff0000;"},label($nopath_name)))));
   print STDERR "FLAGGED File found!\n" if DEBUG;
  }else{
   push(@t_rows,Tr({-align=>'LEFT', -valign=>'BOTTOM'},(td(img({-src=>$finger->{img},-alt=>'Fingerprint '.$finger->{img}})),
                                                        td({'style'=>"font-size:small;"},label($nopath_name)))));
  } 
 }

 print $pop table({-border=>0,
                   -cellpadding=>0,
                   -cellspacing=>0},
                   @t_rows);

 print $pop end_html;
 $pop->close;
 return $popname;
}
